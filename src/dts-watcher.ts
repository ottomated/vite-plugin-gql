import { readFile, writeFile } from 'node:fs/promises';
import { basename, join, relative } from 'node:path';
import { format } from 'prettier';
import type { TypescriptDetails } from './codegen';
import { FSWatcher } from 'chokidar';
import type { GraphQLSchema } from 'graphql';
import type { ProgramNode } from 'rollup';
import { find_import, walk_ast } from './ast';
import { parseAst } from 'rollup/parseAst';

export type TypeMap = {
	[query: string]: TypescriptDetails | { error: string };
};

export class DtsWatcher {
	out_file: string;
	module_id: string;
	schema_promise: Promise<GraphQLSchema>;

	#custom_scalars: Record<string, string> | undefined;
	#file_map = new Map<string, TypeMap>();
	#watcher = new FSWatcher();

	constructor(
		module_id: string,
		out_file: string,
		schema_promise: Promise<GraphQLSchema>,
		custom_scalars: Record<string, string> | undefined,
	) {
		this.module_id = module_id;
		this.out_file = out_file;
		this.schema_promise = schema_promise;
		this.#custom_scalars = custom_scalars;
		this.#watcher.on('change', (path) => {
			this.#update_file_from_watch(path);
		});

		// read cached files
		readFile(this.out_file, 'utf-8')
			.then((text) => {
				const files_raw = text.match(/\/\/ <files>(.*)<\/files>/)?.[1];
				if (!files_raw) return;
				let files: string[];
				try {
					files = JSON.parse(files_raw);
				} catch {
					return;
				}
				if (!Array.isArray(files)) return;
				for (const file of files) {
					if (typeof file !== 'string') continue;
					this.#update_file_from_watch(join(process.cwd(), file));
				}
			})
			.catch(() => {});
	}

	update_file(id: string, types: TypeMap): void {
		const relative_path = relative(process.cwd(), id);

		this.#file_map.set(relative_path, types);
		this.#watcher.add(id);

		clearTimeout(this.write_timeout);
		this.write_timeout = setTimeout(() => {
			this.write_timeout = undefined;
			this.#write();
		}, 100);
	}

	write_timeout: ReturnType<typeof setTimeout> | undefined;

	async #update_file_from_watch(path: string) {
		const code = await readFile(path, 'utf-8').catch(() => null);
		if (code === null) {
			this.#watcher.unwatch(path);
			return;
		}
		let ast: ProgramNode;
		try {
			ast = parseAst(code);
		} catch (_) {
			return;
		}
		const import_name = find_import(ast, this.module_id);
		if (!import_name) return;

		const schema = await this.schema_promise;

		const types = walk_ast(
			{
				ast,
				schema,
				custom_scalars: this.#custom_scalars,
				import_name,
				throw_gql_errors: false,
				magic_string: undefined,
			},
			{
				// swallow warnings during typegen
				warn() {},
				error(err) {
					throw err;
				},
			},
		);

		this.update_file(path, types);
	}

	async #write() {
		let dts = `// ==== This file is auto-generated by @o7/vite-plugin-gql. Do not edit. ====
		// <files>${JSON.stringify(Array.from(this.#file_map.keys()))}</files>
		declare module '${this.module_id}' {
		export type GraphQLError = {
			message: string;
			locations?: Array<{
				line: number;
				column: number;
			}>;
			path?: Array<string | number>;
			extensions?: Record<string, unknown>;
		}\n`;

		for (const [file, types] of this.#file_map) {
			dts += `//#region ${basename(file)}\n`;
			for (const [query, typescript] of Object.entries(types)) {
				if ('error' in typescript) {
					dts += `/** @deprecated ${typescript.error} */
					export default function gql(
						query: ${JSON.stringify(query)},
						variables?: unknown
					): never & {Error: ${JSON.stringify(typescript.error)}};\n`;
					continue;
				}

				const { variables, return_type } = typescript;
				dts += `export default function gql(
					query: ${JSON.stringify(query)},
					variables${variables === null ? '?: undefined' : `: ${variables}`}
				): Promise<{data?: (${return_type}), errors?: Array<GraphQLError>}>;\n`;
			}
		}
		dts += '}';

		const formatted =
			'/* prettier-ignore */\n' +
			(await format(dts, {
				parser: 'typescript',
				trailingComma: 'all',
				useTabs: true,
				singleQuote: true,
			}));

		await writeFile(this.out_file, formatted);
	}
}
