import { readFile, writeFile } from 'node:fs/promises';
import { basename, join, relative } from 'node:path';
import { format } from 'prettier';
import { SCALAR_TYPES, type TypescriptDetails } from './codegen';
import { FSWatcher } from 'chokidar';
import { isScalarType, type GraphQLSchema } from 'graphql';
import type { ProgramNode } from 'rollup';
import { find_import, walk_ast } from './ast';
import { parseAst } from 'vite';
import type { PluginConfig } from '.';
import { loadSchema } from '@graphql-tools/load';
import { UrlLoader } from '@graphql-tools/url-loader';

export type TypeMap = {
	[query: string]: TypescriptDetails | { error: string };
};

export class DtsWatcher {
	out_file: string;
	module_id: string;
	schema_promise: Promise<GraphQLSchema>;

	#custom_scalars: Record<string, string> | undefined;
	#file_map = new Map<string, TypeMap>();
	#watcher = new FSWatcher();

	constructor(
		module_id: string,
		out_file: string,
		schema_promise: Promise<GraphQLSchema>,
		custom_scalars: Record<string, string> | undefined,
	) {
		this.module_id = module_id;
		this.out_file = out_file;
		this.schema_promise = schema_promise;
		this.#custom_scalars = custom_scalars;
		this.#watcher.on('change', (path) => {
			this.#update_file_from_watch(path);
		});

		// read cached files
		readFile(this.out_file, 'utf-8')
			.then((text) => {
				const files_raw = text.match(/\/\/ <files>(.*)<\/files>/)?.[1];
				if (!files_raw) return;
				let files: string[];
				try {
					files = JSON.parse(files_raw);
				} catch {
					return;
				}
				if (!Array.isArray(files)) return;
				for (const file of files) {
					if (typeof file !== 'string') continue;
					this.#update_file_from_watch(join(process.cwd(), file));
				}
			})
			.catch(() => {});
	}

	update_file(id: string, types: TypeMap): void {
		const relative_path = relative(process.cwd(), id);

		this.#file_map.set(relative_path, types);
		this.#watcher.add(id);

		clearTimeout(this.write_timeout);
		this.write_timeout = setTimeout(() => {
			this.write_timeout = undefined;
			write_dts_file(this.#file_map, this.module_id, this.out_file);
		}, 100);
	}

	write_timeout: ReturnType<typeof setTimeout> | undefined;

	async #update_file_from_watch(path: string) {
		const code = await readFile(path, 'utf-8').catch(() => null);
		if (code === null) {
			this.#watcher.unwatch(path);
			return;
		}
		let ast: ProgramNode;
		try {
			ast = parseAst(code);
		} catch (_) {
			return;
		}
		const import_name = find_import(ast, this.module_id);
		if (!import_name) return;

		const schema = await this.schema_promise;

		const types = walk_ast(
			{
				ast,
				schema,
				custom_scalars: this.#custom_scalars,
				import_name,
				throw_gql_errors: false,
				magic_string: undefined,
			},
			{
				// swallow warnings during typegen
				warn() {},
				error(err) {
					throw err;
				},
			},
		);

		this.update_file(path, types);
	}
}

export async function write_dts_file(
	file_map: Map<string, TypeMap>,
	module_id: string,
	out_file: string,
): Promise<void> {
	const sorted_files = Array.from(file_map.entries()).sort((a, b) =>
		a[0].localeCompare(b[0]),
	);
	let dts = `// ==== This file is auto-generated by @o7/vite-plugin-gql. Do not edit. ====
		// <files>${JSON.stringify(sorted_files.map(([file]) => file))}</files>
		declare module '${module_id}' {
		export type GraphQLPromise<T> = Promise<{
			data?: T;
			errors?: Array<GraphQLError>;
		}> & {
			with(overrides: { url?: string, headers?: HeadersInit }): GraphQLPromise<T>;
		};
		export type GraphQLError = {
			message: string;
			locations?: Array<{
				line: number;
				column: number;
			}>;
			path?: Array<string | number>;
			extensions?: Record<string, unknown>;
		}\n`;

	for (const [file, types] of sorted_files) {
		dts += `//#region ${basename(file)}\n`;
		for (const [query, typescript] of Object.entries(types)) {
			if ('error' in typescript) {
				dts += `/** @deprecated ${typescript.error} */
					export default function gql(
						query: ${JSON.stringify(query)},
						variables?: unknown
					): never & {Error: ${JSON.stringify(typescript.error)}};\n`;
				continue;
			}

			const { variables, return_type } = typescript;
			dts += `export default function gql(
					query: ${JSON.stringify(query)},
					variables${variables === null ? '?: undefined' : `: ${variables}`}
				): GraphQLPromise<(${return_type})>;\n`;
		}
	}
	dts += '}';

	const formatted =
		'/* prettier-ignore */\n' +
		(await format(dts, {
			parser: 'typescript',
			trailingComma: 'all',
			useTabs: true,
			singleQuote: true,
		}));

	await writeFile(out_file, formatted);
}

export async function load_schema(
	config: PluginConfig,
	warn: (msg: string) => void,
): Promise<GraphQLSchema> {
	const schema = await loadSchema(config.url, {
		...config.schemaOptions,
		headers: config.headers,
		loaders: [new UrlLoader()],
	});

	for (const [name, type] of Object.entries(schema.getTypeMap())) {
		if (!isScalarType(type)) continue;
		if (name in SCALAR_TYPES) continue;
		if (config.customScalars && name in config.customScalars) continue;
		warn(
			`Scalar '${name}' is missing from config.customScalars. Consider defining it.\n\nDescription: ${type.description ?? ''}`,
		);
	}
	return schema;
}
